Do it! 알고리즘 코딩 테스트: 자바편 

https://www.acmicpc.net/problem/1256

### 풀이


---
### 📄 1단계 문제 분석하기
---
- N + M개 일 때, N개를 뽑는 경우의 수와 N + M개 일 때, M개를 뽑는 경우의 수가 동일하다. 이를 이용해서 배열을 만들고, 조합 점화식을 이용하는 것을 떠올려야한다.

<br>

### 🤘 2단계 손으로 풀기
---

경우의 수에 영향을 주는 것은 "a", "z" 2가지 밖에 없다. 따라서, 모든 "a"를 배치하면 "z"를 어디 배치할 지 고려할 필요가 없다. 반대로도 마찬가지인데, "z"를 배치하면 "a"를 고려할 필요가 없다. 따라서, 둘의 경우의 수가 같다는 것을 알 수 있다.

<br>

그렇다면, n+m 자리에서, m("z")를 선택하는 경우의 수를 계산해보자.

<br>
<img width="342" alt="image" src="https://github.com/2-say/algorithm-study/assets/91319157/8eeedeb5-275d-4bb8-94ea-cfaad7d9e94a">

그래서 d배열을 만들고,

<br>

배열[전체 개수][선택해야하는 수]  == 배열[n+m][m]

<br>

으로 만들면 된다.

그런데, 위 식은 앞에서 봤었던 점화식으로 만들수 있다.

```
D[i][j] = D[i-1][j] + D[i-1][j-1]
```
위 식으로 계산하여, 해당 위치의 맞는 값을 출력하면 된다.


### 👀 3단계 code 분석 
---
문제에서 예외할 조건이 몇가지 있는데, 이 부분만 주의하면 된다.

1. K번째 수열을 구할 수 없으면 -1 출력

주어지는 K의 최대값은 1,000,000,000 이므로, 배열의 결과를 저장할 때, 1,000,000,000를 넘어가면 1,000,000,001 을 저장해서 나중에 비교해서 조건을 만들자.

```
D[i][j] = D[i - 1][j - 1] + D[i - 1][j];
    if (D[i][j] > 1000000000)
        D[i][j] = 1000000001; // K 범위가 넘어가면 범위 최대 값 저장

if (D[N + M][M] < K) // 주어진 자리수로 만들 수 없는 K번째 수이면
    System.out.println("-1");
```

2. 순서의 맞는 az순열 표현하기

처음 n과 m을 비교했을때, 배열의 값이 더 크면 해당 값을 확정하고, 배열의 값이 더 작다면, k의 값을 업데이트하고 z로 확정

"a" 확정한다는 것은 k번째가 해당 경우의 수안에 포함한다는 뜻이기 때문이다. 경우의 수를 벗어나면 무조건 z라는 뜻이고, 다음 경우의 수를 파악

```
while (!(N == 0 && M == 0)) {
    // a를 선택하였을때 남은 문자로 만들 수 있는 모든 경우의 수가 K보다 크면
    if (D[N - 1 + M][M] >= K) {
        System.out.print("a");
        N--;
    } else { // 모든 경우의 수가 K보다 작으면
        System.out.print("z");
        K = K - D[N - 1 + M][M]; // K값 업데이트
        M--;
    }
}
```

<br>
---

### 피드백 👩‍🏫

없음.