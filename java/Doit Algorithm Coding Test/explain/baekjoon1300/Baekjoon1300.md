Do it! 알고리즘 코딩 테스트: 자바편 

https://www.acmicpc.net/problem/1300

### 풀이
---
### 📄 1단계 문제 분석하기
---
- 제한시간 2초 , 데이터 크기 10^10 따라서 O(n^2) 알고리즘을 사용할 수 없음.
- for문을 2번 사용할 수 없다.
<br>

### 🤘 2단계 손으로 풀기
--- 
이 문제에서 이진 탐색이 떠올릴 수 있는 포인트는 
- 나올 수 있는 값의 범위가 주어진다 
<br>

<img width="184" alt="image" src="https://github.com/2-say/algorithm-study/assets/91319157/67da94b2-6e09-4db2-a335-fa6e43e0ee07">

<br>

이 문제에서 나올 수 있는 범위는 (1 ~ k) 이다. 

값을 천천히 살펴보면 1,2,3,4....이런식으로 1씩 증가하는 식으로 주어지고 여기서 <b>중복되는</b> 값이 있을 수 있다. 그렇다면 k번째 있는 수는 k보다 무조건 작거나 같다.

<br>

- 시간 복잡도가 중요한 문제이다.  
<br>

그렇다면 이진 탐색을 사용한다면 시간 복잡도를 logn으로 줄일 수 있다.



---

이진 탐색으로 해당 값이 되는 지 안되는 지 판별하고 된다면 조금 더 범위를 줄이거나 늘려야 한다. 

<br>

근데 어떻게 판별해야할까

<br>

<img width="382" alt="image" src="https://github.com/2-say/algorithm-study/assets/91319157/6029dadc-14cd-4ff8-b78e-94a346ef991f">

<br>

1. mid 값을 정한다. (1~k(7)) = 8/2 = 4

2. mid 값을 첫번째 열로 나눈다면, 몫이 그 행에 mid 보다 작은 개수를 의미하게 된다. 


    ex) 4/2 = 2개  4보다 작거나 같은 값은 2,4 2개다.

3. 4/1 = 4 지만, 배열의 최대 개수가 3 이므로 나올 수 있는 개수의 최대는 3이다. 

4. 위 결과로 모두 더한 값이 K보다 작다면 값의 범위를 줄여서 다시 해본다.

    start = mid + 1

5. 위 결과로 모두 더한 값이 K보다 크다면 답이 될 수도 있다는 뜻이므로 

    answer = mid
    end = mid - 1 

6. start > end가 되면 멈춘 후 결과를 출력하면 된다. 


### 👀 3단계 code 분석 
---
위 요구사항을 그대로 완성하면 해결이 가능하다.

<br>

---

### 피드백 👩‍🏫
없음
