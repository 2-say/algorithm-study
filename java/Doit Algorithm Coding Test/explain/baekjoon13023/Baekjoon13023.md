Do it! 알고리즘 코딩 테스트: 자바편 

https://www.acmicpc.net/problem/13023


### 풀이
---
### 📄 1단계 문제 분석하기
---
- 트리의 깊이를 구하는 문제
- 주의할 점은 도착지를 구하는 문제가 아니기 때문에 모든 트리 경로를 확인해 봐야한다.

<br>

### 🤘 2단계 손으로 풀기
---

<img width="258" alt="image" src="https://github.com/2-say/algorithm-study/assets/91319157/f708b530-e7a8-495f-b074-a7df79268af2">

<br>
이 그래프를 보자, 만약 순차대로 방문한다면, 0 -> 1 -> 2 -> 3 방문 후 멈출 것이다.

<br>
이미 방문 했으니 절대 0 -> 3 -> 2 -> 1 -> 4 인 경로를 찾을 수 없을 것이다. 
<br>

<img width="266" alt="image" src="https://github.com/2-say/algorithm-study/assets/91319157/530a9867-3604-4572-b153-9fc8275f9d4d">


<br>
그렇다면 다음 노드를 방문할때, 경로를 모두 방문해본 후 끝에 도달한다면, 갔던 경로를 체크 해제하도록 만들자.



### 👀 3단계 code 분석 
---
1. 다른 경로 찾을 수 있도록 visited 초기화 하기

```
    visited[start] = true;
    dfs(i,depth+1);
    visited[start] = false;
```
이렇게 한다면 start 가 갈 수 있는 경로를 방문해보고 막다른 길에 도달하면서 다른 경로를 방문할 수 있도록 모든 자물쇠를 풀면서 나오는 꼴이 되므로, 모든 경로를 확인해볼 수 있다.



<br>

2. 주의할 점 
```
for(int i = 0 ; i < n; i ++){
            if(!answer)
                dfs(i, 1);
}
```
Main함수에서 모든 경로를 방문할 시 시간초과가 발생한다. 1번에 dfs로 모두 연결되기 때문에 모두 방문하는 것은 시간 낭비이므로 정답을 발견한다면 멈추도록 구현하자!

<br>

---

### 피드백 👩‍🏫
없음.