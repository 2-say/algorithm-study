Do it! 알고리즘 코딩 테스트: 자바편 

https://www.acmicpc.net/problem/1328

### 풀이
---
### 📄 1단계 문제 분석하기
---
- 점화식을 D[L][R][N]으로 구성해서 해답을 찾아보자
- 크게 3가지로 나눌 수 있다. 
- 제일 작은 길이에 막대가 왼쪽, 오른쪽, 중간에 포함되어 있을 때

그림으로 살펴보자, 
<br>

### 🤘 2단계 손으로 풀기
--- 

왼쪽에 작은 막대가 추가 됨에 따라서, L R에 값이 +1 증가된다.
따라서, 이전에 값과 동일하게 된다.  

따라서, D[L][R][N]은  왼쪽에서 얻은 값 D[L-1][R][N-1] + 오른쪽에서 얻은 값 D[L][R-1][N-1] + 중간에서 얻은 값 
dp[N][L][R] += dp[L][R][N-1] * (N-2) 을 더하면 답이 된다. 

<br>

중간에서 얻은 값이 dp[N][L][R] += dp[L][R][N-1] * (N-2) 인 이유는  
<br>
작은 막대가 어디에 들어가도 L , R은 변하지 않기 때문에 그대로 이고 +  dp[L][R][N-1] 
N개 중 양쪽을 배치하고 나머지 배치할 수 있는 경우의 수는 N-2 이므로 곱하여 준다.


<br>

<img width="384" alt="image" src="https://github.com/2-say/algorithm-study/assets/91319157/d4a79715-2279-4ed2-a255-3d133483cf99">


<img width="384" alt="image" src="https://github.com/2-say/algorithm-study/assets/91319157/3360b91c-71c0-49a0-b4d6-727da1cc8d42">
<br>


위 처럼 눈으로 보면 더욱 명확히 알 수 있다.

---
<br>


### 👀 3단계 code 분석 
---

```
for(int i = 2; i < n+1; i++) {
    dp[i][i][1] = dp[i][1][i] = 1;
    for(int j = 1; j < l+1; j++) {
        for(int k=1; k < r+1; k++) {
            dp[i][j][k] = (dp[i-1][j][k-1] + dp[i-1][j-1][k]   
                                                + (dp[i-1][j][k] * (i-2)))%div;
        }
    }
}
```

점화식 그대로 작성하면 해결할 수 있다.

<br>

---

### 피드백 👩‍🏫
직접 경우의 수를 적어보면서 규칙성을 찾아보도록 노력해보자!
