Do it! 알고리즘 코딩 테스트: 자바편 

https://www.acmicpc.net/problem/13398


### 풀이
---
### 📄 1단계 문제 분석하기
---
- 점화식을 작성해서 풀어보면 된다. 
- 점화식 테이블을 설정하는 것이 중요하다.


처음에 접근했던 방식을 보자. 
단순히 아래 표처럼 접근한다면 아무런 의미가 없다.
왜냐하면 D[1] D[2] D[3]이 모두 10으로 되어야하는데, 바뀌지 않았기 때문이다.

<img width="381" alt="image" src="https://github.com/2-say/algorithm-study/assets/91319157/b642e5fa-7510-4475-8452-4fe0a8d4aadd">

중요한 것은 부분을 이용해서 최대합을 구할 수 있어야한다. 

- 적절한 점화식 정의

<br>

D[N] : 0에서 N까지 길이에서 N을 포함하며 연속으로 수를 선택하여 구할 수 있는 최대합.

<br>

### 🤘 2단계 손으로 풀기
---

중요한 것은 0번~0번까지 고를 수 있는 최대 값은 무조건 하나를 선택해야하므로 10이 된다.

그다음 인덱스는 이전에는 이미 최선에 값을 구해놓았으니 이전 + 다음 배열값을 선택하거나, 배열 값을 선택하거나 할 수 있다. 따라서 다음처럼 나타낼 수 있다. 

A는 처음에 주어진 배열을 의미 L은 최대 합을 선택한 배열

L[i] = Math.max(A[i], L[i-1] + A[i]);

이 문제에서는 가운데 삭제될 수도 있다는 조건이 있기 때문에, 오른쪽에서 최대합을 구한배열과 왼쪽에서 최대합을 구한 배열을 모두를 구하고 그 사이를 제외하여 L[i-1] + R[i+1]을 더해주면 해결할 수 있다.


<img width="421" alt="image" src="https://github.com/2-say/algorithm-study/assets/91319157/bd440c17-f886-4384-bd71-26da53a095f4">

위 표는 위에는 Left 배열, 아래는 Right 배열을 나타내었다. 

<br>

따라서 결과는 6번 인덱스를 제외한

L[5] + R[7] = 21 + 33 = 54로 나온다.


### 👀 3단계 code 분석 
---
1. 왼쪽합 구하기 , 오른쪽도 비슷

```
for(int i = 1 ; i < N ; i++) {
    L[i] = Math.max(A[i], L[i-1] + A[i]);
    result = Math.max(result, L[i]);
}
```

<br>

---

### 피드백 👩‍🏫
없음.