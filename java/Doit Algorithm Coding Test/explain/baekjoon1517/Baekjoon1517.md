### 풀이
---
### 📄 1단계 문제 분석하기
---
- 제한시간 1초, 따라서, 버블정렬 시간복잡도O(n^2)을 사용할 수 없다.
- 다른 정렬 방법을 사용해야한다.
<br>

### 🤘 2단계 손으로 풀기
---
이 문제는 병합 정렬 과정에서 버블정렬의 Swap과정이 포함되어 있음을 떠올릴 수 있다.

자세하게 보자, 


<img width="400" alt="image" src="https://github.com/2-say/algorithm-study/assets/91319157/21fe1214-f708-4916-89f1-98ef13b81600">

<br>
병합 정렬에서 최소 단위로 나눈 후 작은것이 앞으로 큰 것이 뒤로 움직인다.

(새로운 버퍼에 넣는다. 버퍼가 없다면 swap임으로 버블정렬 swap과 같은 과정)

<br>
원래 인덱스에서 앞으로 이동한 것만 즉, 뒤에 있던 것이 더 작을 경우에만 counting을 하면된다. 각 자리 요소가 앞으로 얼마나 이동했는 지 총합을 구하면 답이 된다.



### 👀 3단계 code 분석 
---
1. 병합 정렬을 구현

이 코드에서 병합정렬 그대로 사용하고 딱 한줄만 추가된다. 

구현하는 방법은 코드를 참고.

2. 앞으로 움직인 합 구하기

```
if (arr[divide1] > arr[divide2]) {
    sorted[sortedInd] = arr[divide2];
    answer += divide2 - sortedInd;
    sortedInd++;
    divide2++;
} 
```

[2,1] 이 배열이 있다면 뒤에 1이 더 작으므로 [1,2]로 뒤에 것(1)이 앞으로 한칸 움직인다. 따라서, 원래 인덱스 자리에서 정렬된 위치의 값을 빼주면 된다. 정렬 과정으로 인해 무조건 양수가 된다.

answer += divide2(두번째 인덱스) - (움직인 인덱스(정렬된));


<br>
---

### 피드백 👩‍🏫

플래티넘 문제이지만, 버블정렬 swap 부분이 병합정렬 swap 과정과 비슷하다가는 것을 떠올린다면 금방 풀 수 있는 문제이다. 
하지만, 정렬을 세부적으로 공부하지 않아 쉽게 떠올릴 수 없었다. 알고리즘을 공부할 때, 직접 구현할 수 있을 정도로 자세하게 공부해야겠다.
